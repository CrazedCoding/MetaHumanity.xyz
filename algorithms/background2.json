{
    "name": "Background2",
    "public": true,
    "owner": "MetaHumanity",
    "description": "Meow meow meow. Meow meow meow meow meow meow meow meow meow meow meow meow meow. Meow meow meow meow meow. Meow. Meow meow meow meow meow meow meow meow meow. Meow.",
    "edited": "1603300663742",
    "created":  "1603300663742",
    "type": 14,
    "state": {
        "html": false,
        "client": true,
        "server": false
    },
    "html": "<!--Enter HTML here. -->",
    "client": "var canvas = pipeline.contexts[pipeline.contexts.length-1].canvas;\n\ncanvas.style.position = 'fixed';\ncanvas.style.width = '100%';\ncanvas.style.height = '100%';\ndocument.body.prepend(canvas);\nfunction res(){\n    pipeline.contexts[pipeline.contexts.length-1].resizeCanvas()\n}\nwindow.addEventListener('resize', res);\n",
    "pipeline": {
        "contexts": [
            {
                "name": "image-context",
                "width": {
                    "type": 0,
                    "value": "return 512;"
                },
                "height": {
                    "type": 0,
                    "value": "return 512;"
                },
                "depth_test": false,
                "identifier": "edit_context_identifier_1"
            }
        ],
        "programs": [
            {
                "name": "output-program",
                "uniforms": [
                    {
                        "type": 0,
                        "name": "width",
                        "value": "return pipeline.getContext('image-context').canvas.width;",
                        "identifier": "edit_program_identifier_1_uniform_3"
                    },
                    {
                        "type": 0,
                        "name": "height",
                        "value": "return pipeline.getContext('image-context').canvas.height;",
                        "identifier": "edit_program_identifier_1_uniform_4"
                    },
                    {
                        "type": 0,
                        "name": "time",
                        "value": "if(!this.timeUniformStart) this.timeUniformStart = ((new Date()).getTime())/1E3;\n   return ((new Date()).getTime())/1E3-this.timeUniformStart;",
                        "identifier": "edit_program_identifier_1_uniform_5"
                    }
                ],
                "fragment": "precision highp float;\nprecision highp int;\n\n#define UNIFORM_INSERTION_POINT\n\n#define iTime (time*.0125)\n#define iResolution (vec2(width,height))\n#define fragCoord (iResolution*vPosition)\n\nvarying vec2 vPosition;\n//-----------------CONSTANTS MACROS-----------------\n\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec4 saw(vec4 x)\n{\n    return vec4(saw(x.x), saw(x.y), saw(x.z), saw(x.w));\n}\n\n#define time (sin(((sin(float(__LINE__))*GR/PI+GR/PI/E)*time+100.0)/100.0)*10.0)\n#define sphereN(uv) (clamp(1.0-length(uv*2.0-1.0), 0.0, 1.0))\n#define clip(x) (smoothstep(0.5-GR/PI/E, .5+GR/PI/E, x))\n#define zero(x) (smoothstep(-1.0/PI/E/GR, 1.0/PI/E/GR, sin(x*PI/2.0))*2.0-1.0)\n#define TIMES_DETAILED (1.0)\n#define angle(uv) (atan((uv).y, (uv).x))\n#define angle_percent(uv) ((angle(uv)/PI+1.0)/2.0)\n#define absMin(x,y) (abs(x) < abs(y) ? x: y)\n#define quadrant(uv) (absMin((zero(uv).x), (zero(uv).y))+floor(uv.x/2.0)+floor(uv.y/2.0))\n\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n#define rotatePoint(p,n,theta) (p*cos(theta)+cross(n,p)*sin(theta)+n*dot(p,n) *(1.0-cos(theta)))\n#define GUASS(x) (smoothstep(0.0, 1.0/GR/PI/E, saw(x/2.0)*(1.0-saw(x/2.0))))\n\n#define GRID_COUNT (50.0)\n\n#define MAX_DIM (max(iResolution.x, iResolution.y))\n\n\nfloat seedling = 0.0;\n\nvec2 cmul(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x - v1.y * v2.y, v1.y * v2.x + v1.x * v2.y);\n}\n\nvec2 cdiv(vec2 v1, vec2 v2) {\n\treturn vec2(v1.x * v2.x + v1.y * v2.y, v1.y * v2.x - v1.x * v2.y) / dot(v2, v2);\n}\n\nvec2 mobius(vec2 uv, vec2 multa, vec2 offa, vec2 multb, vec2 offb)\n{\n    return saw(cdiv(cmul(uv, multa) + offa, cmul(uv, multb) + offb))*2.0-1.0;\n}\n\n\nvoid main()\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float scale = exp(sin(time))*GR+1.;\n    uv = uv*scale-scale/2.0;\n    uv.x *= iResolution.x/iResolution.y;\n    //uv = rotatePoint(vec3(uv, 0.0), vec3(0.0, 0.0, 1.0), time/PI).xy;\n    uv += cos(vec2(time, time/GR))/PI/E;\n    vec2 uv0 = uv;\n    float r = length(uv);\n\n    \n    float map = time;\n    float noise = 1.0;\n    float spounge = time*4.0*PI;\n\tconst int max_iterations = 6;\n    int target = max_iterations;//-int(saw(spounge)*float(max_iterations)/2.0);\n    \n    vec2 multa, multb, offa, offb;\n    \n    float magnification = 1.0;\n  \n\tvec3 color = vec3(1.0);\n\tvec3 accum = vec3(0.0);\n    float sum = 0.0;\n    float anticolor = 1.0;\n    seedling = 0.0;\n    \n    float black, white;\n    white = 0.0;\n        \n    float border = 0.0;\n    \n    \n    for(int i = 0; i < max_iterations; i++)\n    {\n        float iteration = float(i)/float(max_iterations);\n        \n        multa = cos(vec2(time*1.1, time*1.2)+iteration*PI);\n        offa = cos(vec2(time*1.3, time*1.4)+iteration*PI)*PI;\n        multb = cos(vec2(time*1.5, time*1.6)+iteration*PI);\n        offb = cos(vec2(time*1.7, time*1.8)+iteration*PI);\n        uv = uv+vec2(cos(seedling*PI), cos(seedling*GR));;\n      \tuv *= GR;\n      \tuv = rotatePoint(vec3(uv, 0.), vec3(0.,0.,1.), (sin(seedling/GR+time))\n                         *time).xy;\n        \n        float q = quadrant(uv);\n        seedling += q+float(i);\n\n        map += (q+seedling)*PI*GR*E;\n        float shift = time;\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.y*PI)))));\n\n        border = max(border, (smoothstep(1.0-1.0/GR/E/PI/2.0, 1.0, (cos(uv.x*PI)))));\n\n        float stripes = map*1.0*PI;//*floor(log(max(iResolution.x, iResolution.y))/log(2.0));\n        float black = smoothstep(0.0, .75, saw(stripes))*clamp(1.0-abs(border), 0.0, 1.0);\n        float white = smoothstep(0.75, 1.0, saw(stripes))*black;\n\n        vec3 final = flux(map*2.0*PI+shift)*black+white;\n\n\n        color *= (final);\n        accum += final;\n        sum += 1.0;\n     \n       \tif(i == max_iterations/2)\n          uv = mobius(uv, multa, offa, multb, offb);\n    }\n    \n    color = pow(color, vec3(1.0/float(max_iterations)));\n    \n    gl_FragColor.rgb = (color+accum/sum)*(1.0-border);\n    gl_FragColor.a = 1.0;\n}\n ",
                "vertex": "precision highp float;\nprecision highp int;\n\n#define UNIFORM_INSERTION_POINT\n\nattribute highp vec4 vertex; \n\nvarying vec2 vPosition;\nvoid main(void) {\n    vPosition = vertex.xy;\n    gl_Position = vec4(vPosition*2.-1., 0., 1.);\n}\n",
                "identifier": "edit_program_identifier_1"
            }
        ],
        "stages": [
            {
                "type": 0,
                "name": "main-stage",
                "context": "image-context",
                "program": "output-program",
                "vertices": "",
                "indices": "",
                "identifier": "edit_stage_identifier_1"
            }
        ]
    },
    "views": 1,
    "loves": [],
    "hates": [],
    "comments": []
}